<!DOCTYPE html>
<html lang="en">
<head>
    <title>Simultaneous Speech Translation - Ultra Low Latency</title>
    <meta charset="utf-8" />
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="./microsoft.cognitiveservices.speech.sdk.bundle.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #0f0f0f;
            color: #e0e0e0;
        }
        .container {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        h1 {
            color: #4fc3f7;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
        }
        .control-panel {
            background: #242424;
            border-radius: 10px;
            padding: 20px;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group h3 {
            color: #4fc3f7;
            margin: 0 0 10px 0;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        select, button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #333;
            border-radius: 6px;
            background: #2a2a2a;
            color: #e0e0e0;
            font-size: 14px;
        }
        select:focus {
            outline: none;
            border-color: #4fc3f7;
        }
        button {
            background: #4fc3f7;
            color: #000;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        button:hover:not(:disabled) {
            background: #29b6f6;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }
        .streaming-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin: 20px 0;
            background: #2a2a2a;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        .streaming-indicator.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(79, 195, 247, 0.3), transparent);
            animation: sweep 2s infinite;
        }
        @keyframes sweep {
            to { left: 100%; }
        }
        .streaming-indicator.active .status-text {
            color: #4fc3f7;
            font-weight: bold;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .metric-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4fc3f7;
        }
        .metric-label {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-top: 5px;
        }
        .translation-area {
            background: #242424;
            border-radius: 10px;
            padding: 20px;
        }
        .waveform-container {
            height: 80px;
            background: #1a1a1a;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        .waveform {
            display: flex;
            align-items: center;
            gap: 2px;
            height: 100%;
        }
        .wave-bar {
            width: 4px;
            background: #4fc3f7;
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        .transcript-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .transcript-box {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            position: relative;
        }
        .transcript-box h4 {
            margin: 0 0 15px 0;
            color: #4fc3f7;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .transcript-segment {
            margin: 10px 0;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 6px;
            border-left: 3px solid #4fc3f7;
            transition: all 0.3s;
        }
        .transcript-segment.interim {
            opacity: 0.7;
            border-left-color: #888;
        }
        .transcript-segment.synthesizing {
            background: #2a3a4a;
            border-left-color: #81c784;
        }
        .timestamp {
            font-size: 0.75em;
            color: #666;
            margin-bottom: 5px;
        }
        .translation-queue {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #242424;
            border-radius: 10px;
            padding: 15px;
            max-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .queue-item {
            background: #2a2a2a;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .queue-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }
        .queue-status.pending { background: #ffa726; }
        .queue-status.speaking { background: #66bb6a; }
        .settings-advanced {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        .slider-container {
            margin: 10px 0;
        }
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #888;
        }
        .warning {
            background: #ff6b6b;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 0.9em;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Simultaneous Speech Translation</h1>
        <p class="subtitle">Ultra-low latency streaming translation with overlapping synthesis</p>
        
        <div class="main-grid">
            <div class="control-panel">
                <div class="control-group">
                    <h3>Source Language</h3>
                    <select id="sourceLanguage">
                        <option value="en-US">English (US)</option>
                        <option value="es-ES">Spanish</option>
                        <option value="fr-FR">French</option>
                        <option value="de-DE">German</option>
                        <option value="zh-CN">Chinese (Mandarin)</option>
                        <option value="ja-JP">Japanese</option>
                        <option value="ko-KR">Korean</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <h3>Target Language</h3>
                    <select id="targetLanguage">
                        <option value="es">Spanish</option>
                        <option value="en">English</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="zh-Hans">Chinese</option>
                        <option value="ja">Japanese</option>
                        <option value="ko">Korean</option>
                    </select>
                    <select id="targetVoice" style="margin-top: 10px;">
                        <option value="es-ES-ElviraNeural">Elvira (Female)</option>
                        <option value="es-ES-AlvaroNeural">Alvaro (Male)</option>
                    </select>
                </div>
                
                <button id="startBtn" onclick="startSimultaneousTranslation()">
                    üöÄ Start Simultaneous Translation
                </button>
                <button id="stopBtn" onclick="stopTranslation()" disabled>
                    ‚èπÔ∏è Stop
                </button>
                
                <div class="streaming-indicator" id="streamingIndicator">
                    <span class="status-text">Ready to translate</span>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-box">
                        <div class="metric-value" id="latencyMetric">--</div>
                        <div class="metric-label">Latency (ms)</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-value" id="throughputMetric">0</div>
                        <div class="metric-label">Words/Min</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-value" id="queueMetric">0</div>
                        <div class="metric-label">Queue Size</div>
                    </div>
                    <div class="metric-box">
                        <div class="metric-value" id="overlapMetric">0%</div>
                        <div class="metric-label">Overlap</div>
                    </div>
                </div>
                
                <div class="settings-advanced">
                    <h3>Advanced Settings</h3>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Chunk Size</span>
                            <span id="chunkSizeValue">5 words</span>
                        </div>
                        <input type="range" id="chunkSize" min="1" max="10" value="5" 
                               oninput="updateChunkSize(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Overlap Threshold</span>
                            <span id="overlapValue">300ms</span>
                        </div>
                        <input type="range" id="overlapThreshold" min="100" max="1000" value="300" step="50"
                               oninput="updateOverlapThreshold(this.value)">
                    </div>
                    <label style="display: block; margin-top: 10px;">
                        <input type="checkbox" id="aggressiveMode" checked>
                        Aggressive streaming mode
                    </label>
                </div>
            </div>
            
            <div class="translation-area">
                <div class="waveform-container">
                    <div class="waveform" id="waveform"></div>
                </div>
                
                <div class="warning" id="warningBox"></div>
                
                <div class="transcript-grid">
                    <div class="transcript-box">
                        <h4>üé§ Original Speech</h4>
                        <div id="sourceTranscript"></div>
                    </div>
                    <div class="transcript-box">
                        <h4>üîä Translation Output</h4>
                        <div id="targetTranscript"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="translation-queue" id="translationQueue">
        <h4 style="margin: 0 0 10px 0; color: #4fc3f7;">Synthesis Queue</h4>
        <div id="queueItems"></div>
    </div>

    <script>
        // Configuration
        let authorizationEndpoint = "http://localhost:3003/api/get-speech-token";
        let authorizationToken;
        let serviceRegion;
        let SpeechSDK;
        let recognizer;
        let synthesizer;
        let translationConfig;
        
        // Streaming state
        let isTranslating = false;
        let synthesisQueue = [];
        let currentlySynthesizing = false;
        let lastRecognizedText = "";
        let chunkBuffer = [];
        let wordsSinceLastSynthesis = 0;
        
        // Performance metrics
        let recognitionStartTime;
        let totalWords = 0;
        let sessionStartTime;
        let synthesisOverlaps = 0;
        let totalSyntheses = 0;
        
        // Settings
        let CHUNK_SIZE = 5; // words
        let OVERLAP_THRESHOLD = 300; // ms
        let AGGRESSIVE_MODE = true;
        
        // Voice mappings
        const voiceMap = {
            'es': [
                { value: 'es-ES-ElviraNeural', text: 'Elvira (Female)' },
                { value: 'es-ES-AlvaroNeural', text: 'Alvaro (Male)' }
            ],
            'en': [
                { value: 'en-US-JennyNeural', text: 'Jenny (Female)' },
                { value: 'en-US-GuyNeural', text: 'Guy (Male)' }
            ],
            'fr': [
                { value: 'fr-FR-DeniseNeural', text: 'Denise (Female)' },
                { value: 'fr-FR-HenriNeural', text: 'Henri (Male)' }
            ],
            'de': [
                { value: 'de-DE-KatjaNeural', text: 'Katja (Female)' },
                { value: 'de-DE-ConradNeural', text: 'Conrad (Male)' }
            ],
            'zh-Hans': [
                { value: 'zh-CN-XiaoxiaoNeural', text: 'Xiaoxiao (Female)' },
                { value: 'zh-CN-YunxiNeural', text: 'Yunxi (Male)' }
            ],
            'ja': [
                { value: 'ja-JP-NanamiNeural', text: 'Nanami (Female)' },
                { value: 'ja-JP-KeitaNeural', text: 'Keita (Male)' }
            ],
            'ko': [
                { value: 'ko-KR-SunHiNeural', text: 'Sun-Hi (Female)' },
                { value: 'ko-KR-InJoonNeural', text: 'InJoon (Male)' }
            ]
        };
        
        // Initialize
        document.addEventListener("DOMContentLoaded", function () {
            Initialize(function (speechSdk) {
                SpeechSDK = speechSdk;
                updateTargetVoices();
                initializeWaveform();
            });
            
            document.getElementById('targetLanguage').addEventListener('change', updateTargetVoices);
        });
        
        function updateTargetVoices() {
            const targetLang = document.getElementById('targetLanguage').value;
            const voiceSelect = document.getElementById('targetVoice');
            const voices = voiceMap[targetLang] || [];
            
            voiceSelect.innerHTML = '';
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.value;
                option.textContent = voice.text;
                voiceSelect.appendChild(option);
            });
        }
        
        function initializeWaveform() {
            const waveform = document.getElementById('waveform');
            for (let i = 0; i < 50; i++) {
                const bar = document.createElement('div');
                bar.className = 'wave-bar';
                bar.style.height = '20px';
                waveform.appendChild(bar);
            }
        }
        
        function animateWaveform() {
            if (!isTranslating) return;
            
            const bars = document.querySelectorAll('.wave-bar');
            bars.forEach((bar, i) => {
                const height = Math.random() * 60 + 20;
                bar.style.height = height + 'px';
            });
            
            requestAnimationFrame(animateWaveform);
        }
        
        async function RequestAuthorizationToken() {
            try {
                const res = await axios.get(authorizationEndpoint);
                authorizationToken = res.data.token;
                serviceRegion = res.data.region;
                return res.data.region;
            } catch (err) {
                showWarning('Failed to get authorization token');
                throw err;
            }
        }
        
        async function startSimultaneousTranslation() {
            try {
                updateStreamingIndicator('Initializing...', true);
                
                await RequestAuthorizationToken();
                
                const sourceLanguage = document.getElementById('sourceLanguage').value;
                const targetLanguage = document.getElementById('targetLanguage').value;
                
                // Create translation config
                translationConfig = SpeechSDK.SpeechTranslationConfig.fromAuthorizationToken(
                    authorizationToken, 
                    serviceRegion
                );
                
                translationConfig.speechRecognitionLanguage = sourceLanguage;
                translationConfig.addTargetLanguage(targetLanguage);
                
                // Enable partial results for streaming
                translationConfig.outputFormat = SpeechSDK.OutputFormat.Detailed;
                translationConfig.setProperty(
                    SpeechSDK.PropertyId.SpeechServiceConnection_TranslationVoice,
                    document.getElementById('targetVoice').value
                );
                
                // Create audio config
                const audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
                
                // Create recognizer
                recognizer = new SpeechSDK.TranslationRecognizer(translationConfig, audioConfig);
                
                // Create synthesizer with streaming config
                const speechConfig = SpeechSDK.SpeechConfig.fromAuthorizationToken(
                    authorizationToken,
                    serviceRegion
                );
                speechConfig.speechSynthesisVoiceName = document.getElementById('targetVoice').value;
                
                // Enable streaming synthesis
                speechConfig.setProperty(
                    SpeechSDK.PropertyId.SpeechServiceConnection_SynthEnableCompressedAudioTransmission,
                    "true"
                );
                
                synthesizer = new SpeechSDK.SpeechSynthesizer(speechConfig);
                
                // Set up streaming event handlers
                setupStreamingRecognition();
                
                // Start continuous recognition
                recognizer.startContinuousRecognitionAsync(
                    () => {
                        isTranslating = true;
                        sessionStartTime = Date.now();
                        updateStreamingIndicator('üé§ Listening and translating...', true);
                        document.getElementById('startBtn').disabled = true;
                        document.getElementById('stopBtn').disabled = false;
                        animateWaveform();
                    },
                    (err) => {
                        showWarning('Failed to start: ' + err);
                        console.error(err);
                    }
                );
                
            } catch (error) {
                showWarning('Initialization failed: ' + error.message);
                console.error(error);
            }
        }
        
        function setupStreamingRecognition() {
            let lastSynthesisTime = 0;
            let currentSegment = { source: '', target: '', startTime: Date.now() };
            
            // Recognizing event - streaming partial results
            recognizer.recognizing = (s, e) => {
                if (e.result.reason === SpeechSDK.ResultReason.TranslatingSpeech) {
                    recognitionStartTime = recognitionStartTime || Date.now();
                    
                    const targetLang = document.getElementById('targetLanguage').value;
                    const translation = e.result.translations.get(targetLang);
                    
                    if (translation && translation.length > 0) {
                        // Update current segment
                        currentSegment.source = e.result.text;
                        currentSegment.target = translation;
                        
                        // Update display immediately
                        updateTranscriptPartial('source', e.result.text);
                        updateTranscriptPartial('target', translation);
                        
                        // Calculate new words since last synthesis
                        const currentWords = translation.split(' ');
                        const newWords = currentWords.slice(wordsSinceLastSynthesis);
                        
                        // Aggressive streaming: synthesize chunks as they arrive
                        if (AGGRESSIVE_MODE && newWords.length >= CHUNK_SIZE) {
                            const chunkToSpeak = newWords.slice(0, CHUNK_SIZE).join(' ');
                            
                            // Check if enough time passed since last synthesis
                            const timeSinceLastSynthesis = Date.now() - lastSynthesisTime;
                            if (timeSinceLastSynthesis > OVERLAP_THRESHOLD) {
                                queueSynthesis(chunkToSpeak, 'partial');
                                wordsSinceLastSynthesis += CHUNK_SIZE;
                                lastSynthesisTime = Date.now();
                            }
                        }
                        
                        updateLatencyMetric();
                    }
                }
            };
            
            // Recognized event - final results
            recognizer.recognized = (s, e) => {
                if (e.result.reason === SpeechSDK.ResultReason.TranslatedSpeech) {
                    const targetLang = document.getElementById('targetLanguage').value;
                    const translation = e.result.translations.get(targetLang);
                    
                    if (translation && translation.length > 0) {
                        // Finalize the segment
                        finalizeTranscriptSegment('source', e.result.text, currentSegment.startTime);
                        finalizeTranscriptSegment('target', translation, currentSegment.startTime);
                        
                        // Synthesize any remaining words
                        const allWords = translation.split(' ');
                        const remainingWords = allWords.slice(wordsSinceLastSynthesis);
                        
                        if (remainingWords.length > 0) {
                            queueSynthesis(remainingWords.join(' '), 'final');
                        }
                        
                        // Reset for next segment
                        wordsSinceLastSynthesis = 0;
                        currentSegment = { source: '', target: '', startTime: Date.now() };
                        
                        // Update metrics
                        totalWords += allWords.length;
                        updateThroughputMetric();
                    }
                }
            };
            
            // Error handling
            recognizer.canceled = (s, e) => {
                console.error('Recognition canceled:', e.errorDetails);
                showWarning('Translation interrupted: ' + e.errorDetails);
                stopTranslation();
            };
        }
        
        function queueSynthesis(text, type) {
            if (!text.trim()) return;
            
            const queueItem = {
                text: text,
                type: type,
                timestamp: Date.now(),
                id: Date.now() + Math.random()
            };
            
            synthesisQueue.push(queueItem);
            updateQueueDisplay();
            updateQueueMetric();
            
            // Process queue if not already processing
            if (!currentlySynthesizing) {
                processSynthesisQueue();
            }
        }
        
        async function processSynthesisQueue() {
            if (synthesisQueue.length === 0 || currentlySynthesizing) return;
            
            currentlySynthesizing = true;
            const item = synthesisQueue.shift();
            
            updateQueueDisplay();
            
            // Mark as synthesizing in transcript
            markAsSynthesizing(item.text);
            
            synthesizer.speakTextAsync(
                item.text,
                result => {
                    if (result.reason === SpeechSDK.ResultReason.SynthesizingAudioCompleted) {
                        totalSyntheses++;
                        if (currentlySynthesizing && synthesisQueue.length > 0) {
                            synthesisOverlaps++;
                            updateOverlapMetric();
                        }
                    }
                    currentlySynthesizing = false;
                    
                    // Process next item
                    if (synthesisQueue.length > 0) {
                        setTimeout(() => processSynthesisQueue(), 50);
                    }
                },
                error => {
                    console.error('Synthesis error:', error);
                    currentlySynthesizing = false;
                    
                    // Try next item
                    if (synthesisQueue.length > 0) {
                        setTimeout(() => processSynthesisQueue(), 100);
                    }
                }
            );
        }
        
        function updateTranscriptPartial(type, text) {
            const container = type === 'source' ? 
                document.getElementById('sourceTranscript') : 
                document.getElementById('targetTranscript');
            
            let interimElement = container.querySelector('.interim-segment');
            if (!interimElement) {
                interimElement = document.createElement('div');
                interimElement.className = 'transcript-segment interim interim-segment';
                container.appendChild(interimElement);
            }
            
            interimElement.innerHTML = `
                <div class="timestamp">${new Date().toLocaleTimeString()} (partial)</div>
                <div>${text}</div>
            `;
            
            container.scrollTop = container.scrollHeight;
        }
        
        function finalizeTranscriptSegment(type, text, startTime) {
            const container = type === 'source' ? 
                document.getElementById('sourceTranscript') : 
                document.getElementById('targetTranscript');
            
            // Remove interim element
            const interimElement = container.querySelector('.interim-segment');
            if (interimElement) {
                interimElement.remove();
            }
            
            // Add final segment
            const segment = document.createElement('div');
            segment.className = 'transcript-segment';
            segment.innerHTML = `
                <div class="timestamp">${new Date(startTime).toLocaleTimeString()}</div>
                <div>${text}</div>
            `;
            
            container.appendChild(segment);
            container.scrollTop = container.scrollHeight;
        }
        
        function markAsSynthesizing(text) {
            const targetContainer = document.getElementById('targetTranscript');
            const segments = targetContainer.querySelectorAll('.transcript-segment');
            
            segments.forEach(segment => {
                if (segment.textContent.includes(text.substring(0, 20))) {
                    segment.classList.add('synthesizing');
                    setTimeout(() => segment.classList.remove('synthesizing'), 1000);
                }
            });
        }
        
        function updateQueueDisplay() {
            const queueItems = document.getElementById('queueItems');
            queueItems.innerHTML = '';
            
            synthesisQueue.slice(0, 5).forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                div.innerHTML = `
                    <div class="queue-status ${index === 0 ? 'pending' : ''}"></div>
                    <div>${item.text.substring(0, 30)}...</div>
                `;
                queueItems.appendChild(div);
            });
            
            if (currentlySynthesizing) {
                const speaking = document.createElement('div');
                speaking.className = 'queue-item';
                speaking.innerHTML = `
                    <div class="queue-status speaking"></div>
                    <div>Speaking...</div>
                `;
                queueItems.insertBefore(speaking, queueItems.firstChild);
            }
        }
        
        function stopTranslation() {
            isTranslating = false;
            
            if (recognizer) {
                recognizer.stopContinuousRecognitionAsync(
                    () => {
                        updateStreamingIndicator('Translation stopped', false);
                        document.getElementById('startBtn').disabled = false;
                        document.getElementById('stopBtn').disabled = true;
                        recognizer.close();
                        recognizer = undefined;
                    },
                    (err) => console.error('Error stopping:', err)
                );
            }
            
            if (synthesizer) {
                synthesizer.close();
                synthesizer = undefined;
            }
            
            // Clear queue
            synthesisQueue = [];
            currentlySynthesizing = false;
            updateQueueDisplay();
        }
        
        // UI Updates
        function updateStreamingIndicator(text, active) {
            const indicator = document.getElementById('streamingIndicator');
            indicator.className = 'streaming-indicator' + (active ? ' active' : '');
            indicator.querySelector('.status-text').textContent = text;
        }
        
        function updateLatencyMetric() {
            if (recognitionStartTime) {
                const latency = Date.now() - recognitionStartTime;
                document.getElementById('latencyMetric').textContent = latency + 'ms';
            }
        }
        
        function updateThroughputMetric() {
            if (sessionStartTime) {
                const minutes = (Date.now() - sessionStartTime) / 60000;
                const wpm = Math.round(totalWords / minutes);
                document.getElementById('throughputMetric').textContent = wpm;
            }
        }
        
        function updateQueueMetric() {
            document.getElementById('queueMetric').textContent = synthesisQueue.length;
        }
        
        function updateOverlapMetric() {
            if (totalSyntheses > 0) {
                const overlapPercentage = Math.round((synthesisOverlaps / totalSyntheses) * 100);
                document.getElementById('overlapMetric').textContent = overlapPercentage + '%';
            }
        }
        
        function updateChunkSize(value) {
            CHUNK_SIZE = parseInt(value);
            document.getElementById('chunkSizeValue').textContent = value + ' words';
        }
        
        function updateOverlapThreshold(value) {
            OVERLAP_THRESHOLD = parseInt(value);
            document.getElementById('overlapValue').textContent = value + 'ms';
        }
        
        function showWarning(message) {
            const warning = document.getElementById('warningBox');
            warning.textContent = message;
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 5000);
        }
        
        // SDK initialization
        function Initialize(onComplete) {
            if (!!window.SpeechSDK) {
                onComplete(window.SpeechSDK);
            }
        }
        
        // Update aggressive mode
        document.getElementById('aggressiveMode').addEventListener('change', (e) => {
            AGGRESSIVE_MODE = e.target.checked;
        });
    </script>
</body>
</html>